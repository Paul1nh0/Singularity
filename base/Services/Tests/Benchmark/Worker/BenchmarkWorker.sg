///////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Research Singularity
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File: Service\Test\Benchmark\Worker\BenchmarkWorker.sg
//
//  Note:
//
using System;
using Microsoft.SingSharp;
using Microsoft.Singularity;
using Microsoft.Singularity.Channels;
using Microsoft.Singularity.Directory;
using Microsoft.Singularity.ServiceManager;
using Microsoft.Singularity.Services;

namespace Microsoft.Singularity.Services.Benchmark
{
    internal class BenchmarkWorker : IRunnable
    {
        private TRef<BenchmarkContract.Exp:Ready>! tref;
        private TRef<ThreadTerminationContract.Exp:Start> signal;

        internal BenchmarkWorker([Claims] BenchmarkContract.Exp:Ready! ep)
        {
            tref = new TRef<BenchmarkContract.Exp:Ready>(ep);
        }

        public void Signal([Claims] ThreadTerminationContract.Exp:Start! sig)
        {
            signal = new TRef<ThreadTerminationContract.Exp:Start>(sig);
        }

        public void Run()
        {
            BenchmarkContract.Exp:Ready!            ep;
            ThreadTerminationContract.Exp:Start!    sig;

            ep = tref.Acquire();
            assert signal != null;
            sig = signal.Acquire();

            for (;;) {
                switch receive {
                    case ep.GetCycleCount():
                        ep.SendCycleCount(Processor.GetCycleCount());
                        break;
                    case ep.Null():
                        ep.SendAckNull();
                        break;
                    case ep.One(arg):
                        ep.SendAckOne(arg);
                        break;
                    case ep.Two(arg1, arg2):
                        ep.SendAckTwo(arg1, arg2);
                        break;
                    case ep.Three(arg1, arg2, arg3):
                        ep.SendAckThree(arg1, arg2, arg3);
                        break;
                    case ep.Four(arg1, arg2, arg3, arg4):
                        ep.SendAckFour(arg1, arg2, arg3, arg4);
                        break;
                    case ep.Five(arg1, arg2, arg3, arg4, arg5):
                        ep.SendAckFive(arg1, arg2, arg3, arg4, arg5);
                        break;
                    case ep.Six(arg1, arg2, arg3, arg4, arg5, arg6):
                        ep.SendAckSix(arg1, arg2, arg3, arg4, arg5, arg6);
                        break;
                    case ep.Seven(arg1, arg2, arg3, arg4, arg5, arg6, arg7):
                        ep.SendAckSeven(arg1, arg2, arg3, arg4, arg5, arg6,
                                        arg7);
                        break;
                    case ep.Eight(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
                                  arg8):
                        ep.SendAckEight(arg1, arg2, arg3, arg4, arg5, arg6,
                                        arg7, arg8);
                        break;
                    case ep.Nine(arg1, arg2, arg3, arg4, arg5, arg6, arg7,
                                 arg8, arg9):
                        ep.SendAckNine(arg1, arg2, arg3, arg4, arg5, arg6,
                                       arg7, arg8, arg9);
                        break;
                        /*
                    case ep.ReadWrite():
                        break;
                    case ep.WriteRead():
                        break;
                        */
                    case ep.EndOfBenchmark():
                        ep.SendAckEnd();
                        goto exit;
                        break;
                    case ep.ChannelClosed():
                        goto exit;
                        break;
                    case sig.Stop():
                        sig.SendAckStop();
                        goto exit;
                        break;
                    case sig.ChannelClosed():
                        goto exit;
                        break;
                }
            }
exit:
            delete ep;
            delete sig;
            DebugStub.Print("BenchExec: Quit main loop\n");
        }
    } // class
}
