///////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Research Singularity
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File: Applications\ServiceManager\Benchmark\Message.sg
//
//  Note:
//
using System;
using System.Threading;
using System.Text;
using Microsoft.SingSharp;
using Microsoft.Singularity;
using Microsoft.Singularity.Channels;
using Microsoft.Singularity.Io;
using Microsoft.Singularity.Services;

namespace Microsoft.Singularity.Applications.ServiceManager
{
    internal class Message
    {
        private const int       MaxArguments = 9;
        private static int[]    n = new int[MaxArguments];

        static Message()
        {
            Random r = new Random();
            for (int i = 0; i < MaxArguments; i++) {
                n[i] = r.Next();
            }
        }

        internal static bool SendReceive(BenchmarkContract.Imp:Ready! ep,
                                         int num,
                                         out ulong time1,
                                         out ulong time2)
        {
            bool success = false;
            
            time1 = 0;
            time2 = 0;
            if (n == null) {
                return false;
            }

            switch (num) {
                case 0:
                    time1 = Processor.GetCycleCount();
                    ep.SendNull();
                    break;
                case 1:
                    time1 = Processor.GetCycleCount();
                    ep.SendOne(n[0]);
                    break;
                case 2:
                    time1 = Processor.GetCycleCount();
                    ep.SendTwo(n[0], n[1]);
                    break;
                case 3:
                    time1 = Processor.GetCycleCount();
                    ep.SendThree(n[0], n[1], n[2]);
                    break;
                case 4:
                    time1 = Processor.GetCycleCount();
                    ep.SendFour(n[0], n[1], n[2], n[3]);
                    break;
                case 5:
                    time1 = Processor.GetCycleCount();
                    ep.SendFive(n[0], n[1], n[2], n[3], n[4]);
                    break;
                case 6:
                    time1 = Processor.GetCycleCount();
                    ep.SendSix(n[0], n[1], n[2], n[3], n[4], n[5]);
                    break;
                case 7:
                    time1 = Processor.GetCycleCount();
                    ep.SendSeven(n[0], n[1], n[2], n[3], n[4], n[5], n[6]);
                    break;
                case 8:
                    time1 = Processor.GetCycleCount();
                    ep.SendEight(n[0], n[1], n[2], n[3], n[4], n[5], n[6],
                                 n[7]);
                    break;
                case 9:
                    time1 = Processor.GetCycleCount();
                    ep.SendNine(n[0], n[1], n[2], n[3], n[4], n[5], n[6],
                                n[7], n[8]);
                    break;
                default:
                    time1 = 0;
                    time2 = 0;
                    return false;
                    break;
            }

            switch receive {
                case ep.AckNull():
                    time2 = Processor.GetCycleCount();
                    success = true;
                    break;
                case ep.AckOne(num1):
                    time2 = Processor.GetCycleCount();
                    success = true;
                    break;
                case ep.AckTwo(num1, num2):
                    time2 = Processor.GetCycleCount();
                    success = true;
                    break;
                case ep.AckThree(num1, num2, num3):
                    time2 = Processor.GetCycleCount();
                    success = true;
                    break;
                case ep.AckFour(num1, num2, num3, num4):
                    time2 = Processor.GetCycleCount();
                    success = true;
                    break;
                case ep.AckFive(num1, num2, num3, num4, num5):
                    time2 = Processor.GetCycleCount();
                    success = true;
                    break;
                case ep.AckSix(num1, num2, num3, num4, num5, num6):
                    time2 = Processor.GetCycleCount();
                    success = true;
                    break;
                case ep.AckSeven(num1, num2, num3, num4, num5, num6, num7):
                    time2 = Processor.GetCycleCount();
                    success = true;
                    break;
                case ep.AckEight(num1, num2, num3, num4, num5, num6, num7,
                                 num8):
                    time2 = Processor.GetCycleCount();
                    success = true;
                    break;
                case ep.AckNine(num1, num2, num3, num4, num5, num6, num7,
                                num8, num9):
                    time2 = Processor.GetCycleCount();
                    success = true;
                    break;
                case ep.ChannelClosed():
                    Console.WriteLine("Job: Server channel closed.\n");
                    success = false;
                    break;
            }
            return success;
        }
 
    } // class
}
