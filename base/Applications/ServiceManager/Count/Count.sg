///////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Research Singularity
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File: Applications\ServiceManager\CountUp\CountUp.sg
//
//  Note:
//
using System;
using System.Threading;
using Microsoft.SingSharp;
using Microsoft.SingSharp.Reflection;
using Microsoft.Singularity;
using Microsoft.Singularity.Applications;
using Microsoft.Singularity.Channels;
using Microsoft.Singularity.Configuration;
using Microsoft.Singularity.Directory;
using Microsoft.Singularity.Io;
using Microsoft.Singularity.Services;
[assembly: Transform(typeof(ApplicationResourceTransform))]

namespace Microsoft.Singularity.Applications
{
    [ConsoleCategory(HelpMessage="Counter client", DefaultAction=true)]
    internal class DefaultConfig
    {
        [InputEndpoint("data")]
        public readonly TRef<UnicodePipeContract.Exp:READY> Stdin;
        
        [OutputEndpoint("data")]
        public readonly TRef<UnicodePipeContract.Imp:READY> Stdout;

        [LongParameter("interval", Position=0, Default=500)]
        internal long interval;

        reflective internal DefaultConfig();

        internal int AppMain()
        {
            return CountUp.DefaultMain(this);
        }
    }

    public class CountUp
    {
        internal static int DefaultMain(DefaultConfig! config)
        {
            bool next;
            ErrorCode error;
            DirectoryServiceContract.Imp ds;
            CounterContract.Imp! ep;
            CounterContract.Exp! server;
            CounterContract.NewChannel(out ep, out server);

            ds = DirectoryService.NewClientEndpoint();
            SdsUtils.Bind(CounterContract.ModuleName, ds, server, out error);

            ep.RecvSuccess();

            Console.WriteLine("Start count");
            ep.SendBeginCount();
            do {
                switch receive {
                    case ep.RecvCurrent(number):
                        Console.WriteLine("Count: " + number);
                        Thread.Sleep((int)config.interval);
                        ep.SendNext();
                        next = true;
                        break;
                    case ep.RecvTerminated():
                        Console.WriteLine("Terminated...");
                        next = false;
                        break;
                    case ep.ChannelClosed():
                        Console.WriteLine("Channel closed...");
                        next = false;
                        break;
                }
            } while (next);

            delete ds;
            delete ep;

            return 0;
        }
    }
}
